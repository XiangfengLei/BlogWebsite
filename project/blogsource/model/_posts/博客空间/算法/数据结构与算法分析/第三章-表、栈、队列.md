---
title: 第三章-表、栈、队列  
date: 2017-12-08 20:53:38  
tags: 博客空间  
categories:   
- 博客空间  
- 算法  
- 数据结构与算法分析  

---
 
1. 抽象数据类型 
--- 
程序设计的基本法则之一是例程不应超过一页。  
抽象数据类型（abstract data type，ADT）是一些操作的集合。对集合ADT，可以有并、交、测定大小以及取余等操作。或者，也可以只要两种操作：并和查找。   
基本想法是，这些操作的实现只在程序中编写一次，而程序中任何其他部分需要在该ADT上运行其中的一种操作时可以通过调用适当的函数来进行。  
<!--more-->
2. 表ADT 
--- 
如A1，A2，A3…，An称为大小是n的表，n=0是为空表。  
除空表外。Ai-1为Ai的前驱元（A1无前驱元），Ai+1为Ai的后继元（An无后继元）。  
操作：打印列表、清空、查找、插入、删除。  

2.1. 表的简单数组实现
---  
数组实现：是动态指定的，但需要对其大小的最大值进行估计。估计得太大就会浪费太大的空间。插入和删除，最坏情况为O(N)，耗时过大。平均来看，需要移动表的一半的元素，需要线性时间。  
2.2  链表  
---
思想：允许表可以不连续存储。  
链表由一系列不必在内存中相连的结构组成，每一结构均含有表元素和指向该元素后继元的结构的指针。  
2.3  程序设计细节  
---
问题1:不存在从所给定义出发在表的前面插入元素的真正显性的方法。  
问题2:从表的前面进行删除，是一个特殊情况，改变了表的起始端，编程中的疏忽将会造成表的丢失。  
问题3:一般的删除，要求记住被删除元素前面的表元。  
解决方法：留出一个标志节点-表头  

（1）表声明：  

	Typedef struct Node *PtrToNode;  
	Typedef PtrToNode Position;  
	Struct Node  
	{  
 		 ElementType Element;  
 		 Position Next;  
	}  

（2）空表和表尾  

	 Return List L->next==NULL;  
 	 Positon->next=NULL；
  
（3）查找 //耗时  

	Position Find(ElementType X,List L)  
	{  
  		Position P;  
 	    P=L->Next;  
  		While(P！=NULL && P->Element!=X)  
			P=P->Next  
 	    Return P;  
	}  
（4）删除  
删除表中的某个元素X；情况1：没有X，什么也不做；情况2：多个X，删除第一次出现的。  

	Void delete(Element X,List L)  
		{  
			Position P,TmpCell;   
			P=FindPrevious(X,L);//找到表中X的前驱元P，比较耗时  
			If(!IsLast(P,L)) //是否为文件尾  
			{  
				TmpCell=P->Next;  
				P->Next=TmpCell->Next;//删除  
				Free(TmpCell);//释放  
			}  
		}  
删除整个表：需要一个临时变量，使用free释放。
  
	Void deleteList  
	{  
		Position P,Tmp;   
		P=L->Next; //表头  
		L->Next=NULL;  
		While(P!=NULL) //将每个指针P进行释放  
		{  
			Tmp=P->Next;  
			Free(P);  
			P=Tmp  
		}  
	}  
（5）插入  
新元素插入到位置P处的前面。  

	Void insert(ElementType X,List L,Position P)  
	{  
		Positon TmpCell;  
		TmpCell=malloc(sizeof(sturct Node));//创建结构，并分配空间  
		If(TmpCell==NULL)  
			FatalError(“Out of space!!!”);    
		TmpCell->Element=X;  
		TmpCell->Next=P->Next;  
		P->Next=TmpCell;  
	}  
2.4  常见的错误  
---
问题1：指针变量未进行初始化。  
问题2：无论何时只要你确定一个指向，那么你就必须保证该指针不是NULL。  
问题3：何时使用malloc来获取一个新的单元。声明指向一个结构的指针并不创建该结构，而只是给其地址。  
malloc：  
（1）创建未被声明的一个新结构，返回该结构的指针。  
（2）如果从未对一个链表进行国删除操作，那么调用malloc的次数等于表的大小，若有表头则加1。  
（3）当使用大量空间时，系统不满足对新单元的要求，此时返回NULL指针。  
（4）malloc(sizeof(PtrToNode))是合法的但是它并不给结构体分配足够的空间。它只给指针分配一个空间。  
2.5  双链表  
---
增加指向前一个单元的指针。  
不足之处：  
增加了空间的需求。  
插入和删除的开销增加一倍  
好处：简化了删除操作。  
2.6  循环链表  
---
双向链表，且最后一个单元指针指向第一个单元。  
2.7  例子  
---
2.7.1  多项式ADT 
---- 
![](https://i.imgur.com/8KvJJZA.png)  
如果F(X)=10X^1000+5X^14+1。那么就有很多时间浪费在计算系数为0的操作。  
解决办法：  

2.7.2  基数排序-卡式排序  
---
对N个整数，从1～M进行排序，称为桶式排序。  

2.7.3  多重表  
---

2.7.4 链表的游标实现  
---
在链表的指针实现中有两个重要的特点：  
1、数据存储在一组结构体中。每一个结构体包含有数据以及指向一个结构体的指针。  
2、一个新的结构体可以通过调到malloc而从系统全局内存得到，并通过free释放。游标法必须能够模仿这两条特性。  
3 栈ADT  
---
3.1 栈模型-LIFO（先进后出）  
---
是限制插入和删除只能在一个位置上进行的表。表的末端-栈顶  
基本操作： Push 进栈和Pop 出栈。  
3.2 栈的实现  
---
栈是一个表，任何实现表的方法都能实现栈。  
栈的链表实现  
（1）单链表  
表顶插入实现Push；  
删除表顶端元素实现Pop。  
声明：与链表的声明一样 
 
	Struct Node  
	{  
		ElementType Element;  
		PtrToNode Next;  
	};  
空栈测试：与链表一样  

	Int IsEmpty(Stack S)  
	{  
		Return S->next==NULL;  
	}  
创建空栈： 
  
	Stack CreateStack(void) 
	{  
		Stack S;  
		S=malloc(sizeof(struct Node));  
		If(S==NULL)  
			FatalError(“Out of space!!!”);  
		S->Next==NULL;  
		MakeEmpty(S);  
		Return S;  
	}  

	Void MakeEmpty(Stack S) //置空，将每个数据进行出栈  
	{  
		If(S==NULL)  
			Error(“Must use CreateStack first”);  
		Else   
			While(!IsEmpty(S))  
				Pop(S);  
	}  
进栈：与表的插入类似
  
	Void Push(ElementType X,Stack S)  
	{  
 		PtrToNode TmpCell  
 		TmpCell=malloc(sizeof(struct Node));  
		If(TmpCell==NULL) //系统内存可能不足了，分配空间失败  
			FatalError(“out of space”);  
		Else  
			TmpCell->Element=x;  
		TmpCell->Next=S->Next;  
		S->Next=TmpCell;  
	}  
返回栈顶元素 
 
	ElementType Top(Stack S)  
	{  
		If(!IsEmpty(S))  
			Return S->Next->Element;  
  		Error(“Empty stack”);  
		Return 0;  
	}  
出栈：栈元素删除 
 
	Void Pop(Stack S)  
	{  
		PrtToNode FirstCell;  
		If(IsEmpty(S))  
			Error(“Empty stack”)  
		Else  
		{  
			FirstCell=S->Next;  
			S->Next=S->Next->Next;  
			Free(FirstCell);  
		}  
	}  
缺点： malloc和free的开销较大。  
（2）栈的数组实现  
提前声明一个数组的大小。Stack(TopOfStack)=X。出栈时TopOfStack减1，入栈是TopOfStack加1。   
影响栈的执行效率的问题是错误检测：  
4 队列ADT  
---
队列(queue)也是表。插入（入队）在队尾（rear），删除（出队）在队头（front）。  
4.1 队列的数组实现。 
--- 
队列信息： 数组queue[],队尾Rear队头,Front,实际存在元素大小Size。  
X值入队：，size++；Rear++；然后queue[Rear]=X  
出队：return queue[Front];Size--;Front++;  
潜在问题：入队满了后，再次入队就会失败。  
解决方法：当Front或Rear到达数组的尾端，就绕回开头。称为循环数组实现。  
注意：1、检测队列是否为空。  
	  2、不同的设计人员会用不同的方法表示队头和队尾。  
队列的大小是通过比较Rear和Front隐式算出的。  