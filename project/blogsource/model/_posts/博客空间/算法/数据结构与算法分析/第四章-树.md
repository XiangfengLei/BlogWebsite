---
title: 第四章-树 
date: 2017-12-09 21:51:38  
tags: 博客空间  
categories:   
- 博客空间    
- 算法
- 数据结构与算法分析  

---

1 预备知识  
---
（1）根（root）节点唯一，非空树  
（2）子树、父亲、儿子、兄弟、叶子  
（3）结点拥有的子树称为结点的度(Degree)，度为0的结点称为叶子结点。  
（4）树的度是树各结点的度的最大值  
（5）结点的层数从根开始，根为第一层，叶子为最后一层。树中结点的最大层次称为树的深度和高度。  
（6）如果各子树看成从左至右不可互换的，则称为有序树，否则称为无序树。  
（7）森林是互不相交的树的集合，某个结点的子树可以看做是森林。 
<!--more--> 
1.1 树的实现  
---
实现方法：将每个结点的所有儿子都放在树结点的链表中。  
声明：  
	Typedef struct TreeNode *PrtToNode;  
	Struct TreeNode  
	{  
		ElementType Element;  
		PtrToNode FirstChild;  
		PrtToNode NextSibling;  
	}   
1.2 树的遍历及应用
---
![](https://i.imgur.com/iMq8cxg.jpg)  
先序遍历：ABDCE  
中序遍历：DBAEC  
后序遍历：DEBCA  
层序遍历：ABCDE  
使用递归的方式实现。  
流行应用于操作系统的目录结构。  
2 二叉树  
---
二叉树(binary tree)是一棵树，其中每个结点最多两个儿子。  
平均深度为O(sqrt(N))  
二叉查找树(binary search tree)，其深度的平均值是O(log N)。  
2.1 实现
---
声明：树节点由key(关键字)加上两个指针（指向Left和Right）
  
	Typedef struct TreeNode *PtrToNode;  
	Typedef struct PrtToNode Tree;  
	Struct TreeNode
	{  
		ElementType Element;  
		Tree Left;  
		Tree Right;  
	}  

2.2表达式树
---
使用后序遍历得出后缀表达式。  

![](https://i.imgur.com/oIhLBVf.png)  

“(a+b*c)+((d*e+f)*g)”的表达式树  
后序遍历得到的后缀表达式为：abc*+de*f+g*+  
先序遍历得到的前缀记法：++a*bc*+*defg  
构造一颗表达式树：由后缀表达式转变为表达式树  
例子ab+cde+**  
简要说明：  
（1）先将操作树压入栈中  
（2）遇到操作符弹出，构建一个节点  
节点：不包括叶子结点  
结点：所有结点，包括根和叶子  
3 查找树ADT——二叉查找树  
---
二叉查找树的性质：对于每个节点X，左子树的关键字小于X的关键字，右子树关键字大于X的关键字。  
3.1 MakeEmpty
---
声明  

	Struct TreeNode  
	{  
		ElementType Element;  
		SearchTree Left;  
		SearchTree Right;  
	};  

	SearchTree MakeEmpty(SearchTree T)  
	{  
		If(T!=NULL)  
		{  
			MakeEmpty(T->Left);  
			MakeEmpty(T->Right);  
			Free(T);  
		}  
		Return T;  
	}  
3.2 Find  
---
返回树T中具有关键字X的节点的指针，不存在则返回NULL。  
实现方式：递归。  
注意：判断是否为空。  

	Position Find(ElementType X,SearchTree T)  
	{  
		If(T==NULL)  
			Return NULL;  
		If(X<T->Element)  
			Return Find(X,T->Left) //左子树递归  
		else  
	If(X>T->Element)  
		Return Find(X,T->Right);  
	Else  
		Return T;  
	}  
3.3 FindMin和FinMax
---
	Position FindMin(SearchTree T)  
	{  
		If(T==NULL)  
			Return NULL;  
		Else  
		If(T->left==NULL)  
			Return T; //进行左子树递归，最终返回结点T  
		Else  
			Return FindMin(T->Left);  
	}  
	Position FindMax(SearchTree T)  
	{	  
		If(T!=NULL)  
			While(T->Right!=NULL)  
				T=T->Right;  
		Return T;  
	}   
3.4 Insert
---
插入X操作：用Find查找X，如果找到X，则什么也不做（或做一些“更新”）。否则将X插入到遍历路径上的最后一个点。  
重复元的插入可以通过在结点记录中保留一个附加域以指示发生的频率来处理。这种方法增加了某些附加空间。但比重复信息放到树中的好（将使树变得更大）。  
如果关键字只是一个更大结构的一部分，那么这种方法是不行的，此时我们可以把具有相同关键字的所有结构保留在一个辅助结构中，如表或另一棵查找树中。  
3.5 Delete
---
实现策略：用右子树的最小数据代替该节点的数据并递归的删除那个节点。因为右子树的最小节点不可能有左儿子。效率不高。  
删除的次数不多，采用懒惰删除(lazy deletion)：当一个元素要被删除时，它仍留在树中，而只是做了个删除的标记。  
小损耗；如果重新插入，那么就省下分配新的单元的时间。  
3.6平均情形分析
---
上述的删除算法使得左子树比右子树深度深，当插入和删除次多较多时，会造成树明显的不平衡。  
方法：我们可以通过随机选取右子树的最小元素或左子树的最大元素来代替被删除的元素以消除这种不平衡问题  
。。。。。。  
4 AVL树
---
一棵AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树。——平衡树。  
保证深度为O(logN)。  
不平衡可能出现四种情况：  

4.1 单旋转  
---
	Static Position SingleRotateWithLeft(Position K2)  
	{  
		Position K1;  
		K1=K2->Left;  
		K2->Left=K1->Right;  
		K2->Right=K2;  
		K2->Height=Max(Height(K2->Left),Height(k2->Right))+1;  
		K1->Height=Max(Height(K1->Left),Height(k2->Right))+1;  
		Return K1;  
	}  
4.2 双旋转  
---

	Static Position DoubleRotateWithLeft(Position K3)  
	{  
		K3->Left=SingleRotateWithRight(K3->Left);  
		Return SingleRotateWithLeft(K3);  
	}  
